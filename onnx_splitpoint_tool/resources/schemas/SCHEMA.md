# Benchmark plan & manifest schema (v1)

These JSON files are generated by the ONNX Splitpoint Tool when exporting splits and benchmark sets.

Design goals:
- **Minimal**: only the information needed to run/validate a split.
- **Extensible**: supports future features (e.g. stage1/stage2 on different accelerators).
- **Backwards-compatible**: legacy flat keys remain in `split_manifest.json`.

## Files

### `split_manifest.json` (per case)
- Purpose: describes one split boundary and the artifacts in that case folder.
- Required keys (v1):
  - `schema = "onnx-splitpoint/split-manifest"`
  - `schema_version = 1`
  - `boundary`
  - `part1_model`, `part2_model`
- Recommended normalized sections:
  - `models`: paths for full/part1/part2
  - `cut`: mapping between cut tensor names (part1 outputs ↔ part2 inputs)
  - `io`: original inputs/outputs and external inputs per stage
  - `pipeline`: explicit links for part1→part2 tensor handoff
  - `hailo`: optional HEF/HAR artifacts per `hw_arch`

### `benchmark_plan.json` (suite-level)
- Purpose: tells the suite runner which runs to execute (ORT CPU/CUDA/TRT, Hailo-8/10, etc.)
- Required keys (v1):
  - `schema = "onnx-splitpoint/benchmark-plan"`
  - `schema_version = 1`
  - `runs`: list of run objects
- Each run has:
  - `id`
  - `type` (`onnxruntime`/`ort` or `hailo`)
  - `provider` (for ORT) and/or `hw_arch` (for Hailo)
  - Optional `stage1`/`stage2` for future matrix support

### `benchmark_set.json` (suite-level)
- Purpose: the canonical index of cases + predicted metrics.
- Contains an embedded `plan` (same content as `benchmark_plan.json`) for convenience.

## Future: Matrix runs (stage1 on A, stage2 on B)
The schema already reserves:
- `benchmark_plan.json["matrix"]` and/or per-run `stage1`/`stage2`.

A future version can add a dedicated runner to:
- run stage1 on accelerator A
- serialize cut tensors
- run stage2 on accelerator B
